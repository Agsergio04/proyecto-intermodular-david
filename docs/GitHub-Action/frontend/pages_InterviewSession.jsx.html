<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: pages/InterviewSession.jsx</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: pages/InterviewSession.jsx</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview PÃ¡gina de sesiÃ³n interactiva de entrevista tÃ©cnica.
 * Gestiona el flujo completo de una entrevista incluyendo:
 * - NavegaciÃ³n entre preguntas
 * - Reconocimiento de voz mediante Web Speech API
 * - Guardado de respuestas en el backend
 * - Vista de resultados y feedback generado por IA
 * 
 * @module pages/InterviewSession
 * @requires react
 * @requires react-router-dom
 * @requires react-i18next
 * @requires react-toastify
 * @requires react-icons/fi
 * @requires ../api
 * @requires ../store
 * @requires ../assets/styles/InterviewSession.css
 */

/**
 * Componente principal de sesiÃ³n de entrevista interactiva.
 * Gestiona navegaciÃ³n entre preguntas, reconocimiento de voz, guardado de respuestas
 * y vista de resultados completados con feedback de IA.
 * 
 * @component
 * @returns {JSX.Element} Interfaz completa de sesiÃ³n de entrevista
 * 
 * @description
 * Componente que maneja el flujo completo de una entrevista tÃ©cnica:
 * 
 * **Funcionalidades principales:**
 * - Carga entrevista y preguntas desde API
 * - Captura respuestas mediante texto o voz (Web Speech API)
 * - Almacena respuestas en backend automÃ¡ticamente
 * - Navega entre preguntas con indicador de progreso
 * - Genera feedback con IA al finalizar
 * - Muestra vista completa de resultados con puntuaciones
 * - Soporta tema claro/oscuro
 * 
 * **Estados principales:**
 * - interview: Datos de la entrevista actual
 * - currentQuestion: Ãndice de la pregunta actual
 * - responses: Respuestas temporales del usuario (antes de guardar)
 * - isListening: Si micrÃ³fono estÃ¡ grabando
 * - isConfirming: Si hay respuesta de voz pendiente de confirmaciÃ³n
 * - userAnswer: Texto transcrito del micrÃ³fono
 * - elapsedTime: Tiempo de grabaciÃ³n actual
 * - totalTime: Tiempo total desde inicio de sesiÃ³n
 * 
 * **Flujo de la sesiÃ³n:**
 * 1. Cargar entrevista y preguntas
 * 2. Mostrar pregunta actual
 * 3. Usuario responde por texto o voz
 * 4. Guardar respuesta en backend
 * 5. Navegar a siguiente pregunta
 * 6. Repetir hasta Ãºltima pregunta
 * 7. Generar feedback con IA
 * 8. Mostrar resultados con puntuaciones
 * 
 * @example
 * // Uso en rutas de App.js
 * &lt;Route
 *   path="/interview/:interviewId"
 *   element={&lt;ProtectedRoute>&lt;InterviewSession />&lt;/ProtectedRoute>}
 * />
 */

import React, { useState, useEffect, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useTranslation } from 'react-i18next';
import { toast } from 'react-toastify';
import { interviewService, responseService } from '../api';
import { FiArrowLeft, FiArrowRight, FiX, FiCheck } from 'react-icons/fi';
import { useThemeStore } from '../store';
import '../assets/styles/InterviewSession.css';

/**
 * Icono SVG del micrÃ³fono para reconocimiento de voz.
 * Utiliza un icono animado que indica disponibilidad para grabaciÃ³n.
 * 
 * @function MicrophoneIcon
 * @returns {JSX.Element} Elemento SVG del icono de micrÃ³fono
 */
const MicrophoneIcon = () => (
  &lt;svg xmlns="http://www.w3.org/2000/svg" className="interview-session__mic-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
    &lt;path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
  &lt;/svg>
);

/**
 * Convierte segundos a formato legible MM:SS para mostrar en cronÃ³metro.
 * Ejemplo: 125 segundos â†’ "02:05", 5 segundos â†’ "00:05"
 * 
 * @function formatTime
 * @param {number} seconds - NÃºmero entero de segundos a convertir (ej: 125)
 * @returns {string} Tiempo formateado como string "MM:SS" con ceros a la izquierda (ej: "02:05")
 * 
 * @example
 * formatTime(125) // Returns "02:05"
 * formatTime(5)   // Returns "00:05"
 * formatTime(3661) // Returns "61:01"
 */
const formatTime = (seconds) => {
  const minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
  const secs = (seconds % 60).toString().padStart(2, '0');
  return `${minutes}:${secs}`;
};

const InterviewSession = () => {
  const { interviewId } = useParams();
  const navigate = useNavigate();
  const { t } = useTranslation();
  const { isDark } = useThemeStore();

  // ========== Estados del Formulario ==========
  /** @type {[Object|null, Function]} Estado que almacena la entrevista cargada con todas sus preguntas y metadata */
  const [interview, setInterview] = useState(/** @type {Object|null} */ null);
  /** @type {[number, Function]} Ãndice (0-based) de la pregunta actual que se estÃ¡ mostrando */
  const [currentQuestion, setCurrentQuestion] = useState(/** @type {number} */ 0);
  /** @type {[boolean, Function]} Indica si se estÃ¡ cargando la entrevista desde el backend */
  const [loading, setLoading] = useState(/** @type {boolean} */ true);
  /** @type {[Object, Function]} Diccionario que almacena respuestas por ID de pregunta: { [questionId]: "respuesta de usuario" } */
  const [responses, setResponses] = useState(/** @type {Object} */ {});
  /** @type {[boolean, Function]} Indica si se estÃ¡ enviando respuesta o feedback al backend */
  const [submitting, setSubmitting] = useState(/** @type {boolean} */ false);

  // ========== Estados del Reconocimiento de Voz ==========
  /** @type {[boolean, Function]} True cuando micrÃ³fono estÃ¡ activo capturando audio */
  const [isListening, setIsListening] = useState(/** @type {boolean} */ false);
  /** @type {[boolean, Function]} True cuando hay transcripciÃ³n de voz esperando confirmaciÃ³n del usuario */
  const [isConfirming, setIsConfirming] = useState(/** @type {boolean} */ false);
  /** @type {[string, Function]} Texto transcrito del reconocimiento de voz, antes de ser confirmado */
  const [userAnswer, setUserAnswer] = useState(/** @type {string} */ '');
  /** @type {[string, Function]} Mensaje de estado actual del micrÃ³fono ('escuchando', 'procesando', etc.) */
  const [voiceStatus, setVoiceStatus] = useState(''); 
  /** @type {[number, Function]} Tiempo transcurrido (en segundos) durante la grabaciÃ³n actual de voz */
  const [elapsedTime, setElapsedTime] = useState(/** @type {number} */ 0);
  /** @type {[number, Function]} Tiempo total (en segundos) desde inicio de la sesiÃ³n de entrevista */
  const [totalTime, setTotalTime] = useState(/** @type {number} */ 0);

  // ========== Referencias ==========
  /** @type {React.MutableRefObject&lt;SpeechRecognition|null>} Referencia a la instancia de Web Speech Recognition API */
  const recognitionRef = useRef(/** @type {SpeechRecognition|null} */ null);
  /** @type {React.MutableRefObject&lt;string>} Buffer mutable para acumular texto transcrito sin causar re-renders */
  const userAnswerRef = useRef('');
  /** @type {React.MutableRefObject&lt;NodeJS.Timeout|null>} ID del intervalo que actualiza totalTime cada segundo */
  const totalTimeIntervalRef = useRef(/** @type {NodeJS.Timeout|null} */ null);

  /**
   * Hook de inicializaciÃ³n: carga la entrevista cuando el componente monta o cambia el interviewId.
   * Este efecto es crÃ­tico para el ciclo de vida del componente.
   * 
   * @dependencies [interviewId] - Se ejecuta cuando el ID de entrevista cambia en la ruta
   * @sideEffects Llama a fetchInterview() que carga datos del backend y actualiza estados
   */
  useEffect(() => {
    fetchInterview();
    // eslint-disable-next-line
  }, [interviewId]);

  /**
   * Hook de inicializaciÃ³n: configura el reconocimiento de voz y el temporizador global.
   * Ejecutado una sola vez al montar el componente (effect de limpieza incluida).
   * 
   * @sideEffects
   * - Inicializa SpeechRecognition (W3C Web Speech API)
   * - Configura handlers: onresult (transcripciÃ³n), onend (finalizaciÃ³n), onerror
   * - Inicia intervalo que incrementa totalTime cada segundo
   * - Pausa el intervalo cuando el usuario finaliza la entrevista
   * 
   * @returns {Function} Cleanup function que detiene el intervalo y detiene el reconocimiento
   */
  useEffect(() => {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SpeechRecognition) {
      recognitionRef.current = new SpeechRecognition();
      recognitionRef.current.continuous = true;
      recognitionRef.current.interimResults = true;
      recognitionRef.current.lang = 'es-ES';

      recognitionRef.current.onresult = (event) => {
        let finalTranscript = '';
        let interimTranscript = '';
        for (let i = event.resultIndex; i &lt; event.results.length; ++i) {
         if (event.results[i].isFinal) {
           finalTranscript += event.results[i][0].transcript;
         } else {
           interimTranscript += event.results[i][0].transcript;
         }
        }

        if (finalTranscript) {
         setUserAnswer(prev => {
           const newAnswer = prev + finalTranscript;
           userAnswerRef.current = newAnswer;
           return newAnswer;
         });
        }
        if (interimTranscript) setVoiceStatus(`Escuchando: ${interimTranscript}`);
      };

      recognitionRef.current.onend = () => {
        setIsListening(false);
        if (userAnswerRef.current.trim()) {
          setIsConfirming(true);
          setVoiceStatus('Revisa tu respuesta y confirma o reintenta.');
        } else {
          setVoiceStatus('Haz clic en el micrÃ³fono para intentarlo de nuevo.');
        }
      };

      recognitionRef.current.onerror = (event) => {
        console.error('Speech recognition error', event.error);
        setVoiceStatus('Error de reconocimiento de voz. Revisa tu micrÃ³fono.');
        setIsListening(false);
        toast.error('Error de reconocimiento de voz.');
      };

      totalTimeIntervalRef.current = window.setInterval(() => {
        setTotalTime(prev => prev + 1);
      }, 1000);
    } else {
      setVoiceStatus('El reconocimiento de voz no es compatible con tu navegador.');
      toast.error('Reconocimiento de voz no soportado.');
    }

    return () => {
      if (recognitionRef.current) recognitionRef.current.stop();
      if (totalTimeIntervalRef.current) clearInterval(totalTimeIntervalRef.current);
    };
  }, []);

  /**
   * Temporizador para tiempo de grabaciÃ³n por pregunta.
   * Incrementa elapsedTime cada segundo mientras el micrÃ³fono estÃ¡ activo.
   * Se reinicia al cambiar de pregunta.
   * 
   * @dependencies [isListening] - Se ejecuta cuando se activa/desactiva el micrÃ³fono
   * @sideEffects Actualiza elapsedTime cada segundo durante grabaciÃ³n activa
   * @returns {Function} Cleanup function que detiene el intervalo
   */
  useEffect(() => {
    let answerTimer;
    if (isListening) {
      answerTimer = window.setInterval(() => {
        setElapsedTime(prev => prev + 1);
      }, 1000);
    }
    return () => clearInterval(answerTimer);
  }, [isListening]);

  /**
   * Carga la entrevista completa desde el backend.
   * 
   * Realiza las siguientes operaciones:
   * 1. Obtiene datos de la entrevista con todas sus preguntas
   * 2. Si estÃ¡ "in_progress", restaura las respuestas previas guardadas
   * 3. Mapea las respuestas por Ã­ndice de pregunta para rellenar el textarea
   * 4. Maneja errores y navega a /interviews si falla
   * 
   * @async
   * @returns {Promise&lt;void>}
   * @sideEffects
   * - setLoading(true) â†’ setLoading(false): Muestra/oculta spinner de carga
   * - setInterview(): Almacena la entrevista completa
   * - setResponses(): Restaura respuestas previas en formato { [questionIndex]: "text" }
   * - toast.error(): Muestra notificaciÃ³n si falla
   * - navigate('/interviews'): Redirige si hay error crÃ­tico
   * 
   * @example
   * // Se llama automÃ¡ticamente en el useEffect al montar o cambiar interviewId
   * // TambiÃ©n puede ser llamada manualmente para refrescar datos
   * await fetchInterview();
   */
  const fetchInterview = async () => {
    try {
      setLoading(true);
      const response = await interviewService.getInterview(interviewId);
      const interviewData = response.data.interview;
      
      // Debug: ver quÃ© datos llegan
      console.log('ðŸ“Š Interview data:', interviewData);
      console.log('ðŸ“Š Questions:', interviewData.questions);
      if (interviewData.questions &amp;&amp; interviewData.questions.length > 0) {
        console.log('ðŸ“Š First question responses:', interviewData.questions[0].responses);
        interviewData.questions.forEach((q, idx) => {
         console.log(`ðŸ“Š Question ${idx + 1} has ${q?.responses?.length || 0} responses`);
        });
      }
      
      setInterview(interviewData);

      if (interviewData.status === 'in_progress') {
        const map = {};
        (interviewData.questions || []).forEach((q, idx) => {
         if (q?.responses?.[0]?.responseText)
           map[idx] = q.responses[0].responseText;
        });
        setResponses(map);
      }
    } catch (error) {
      toast.error(error.response?.data?.message || 'Error loading interview');
      navigate('/interviews');
    } finally {
      setLoading(false);
    }
  };

  const isCompleted = interview &amp;&amp; interview.status === 'completed';
  const isInProgress = interview &amp;&amp; interview.status === 'in_progress';
  const questions = interview?.questions || [];
  const question = questions[currentQuestion] || {};

  // Obtener la ÃšLTIMA respuesta guardada (no la primera)
  const questionResponses = question?.responses || [];
  const lastResponse = questionResponses.length > 0 
    ? questionResponses[questionResponses.length - 1] 
    : null;
  const responseSaved = lastResponse?.responseText || '';
  const localResponse = responses[currentQuestion] || '';

  /**
   * Verifica si todas las preguntas tienen al menos una respuesta.
   * 
   * EvalÃºa tanto respuestas guardadas en el backend como respuestas temporales en el estado local:
   * - Para entrevistas completadas: verifica si hay respuesta guardada con texto no vacÃ­o
   * - Para entrevistas en progreso: verifica si hay respuesta temporal O guardada
   * 
   * @type {boolean}
   * @returns {boolean} true si todas las preguntas tienen respuesta, false si alguna estÃ¡ vacÃ­a
   */
  const allAnswered = questions.every((q, idx) => {
    if (isCompleted) {
      const qResponses = q?.responses || [];
      return qResponses.length > 0 &amp;&amp; qResponses[qResponses.length - 1]?.responseText?.trim().length > 0;
    }
    const qResponses = q?.responses || [];
    const lastSaved = qResponses.length > 0 ? qResponses[qResponses.length - 1]?.responseText : null;
    const temp = responses[idx];
    return (temp &amp;&amp; temp.trim().length > 0) || (lastSaved &amp;&amp; lastSaved.trim().length > 0);
  });

  /**
   * Actualiza la respuesta temporal del usuario en el textarea.
   * Esta funciÃ³n NO envÃ­a a backend; solo actualiza el estado local (responses).
   * El guardado en backend ocurre cuando el usuario navega a otra pregunta o finaliza.
   * 
   * @function handleResponseChange
   * @param {React.ChangeEvent&lt;HTMLTextAreaElement>} e - Evento del textarea con el nuevo valor de texto
   * @sideEffects Actualiza state: responses[currentQuestion] = e.target.value
   * 
   * @example
   * // Usuario escribe en textarea â†’ dispara onChange â†’ handleResponseChange actualiza responses
   * &lt;textarea onChange={handleResponseChange} value={responses[currentQuestion] || ''} />
   */
  const handleResponseChange = (e) => {
    setResponses((prev) => ({
      ...prev,
      [currentQuestion]: e.target.value
    }));
  };

  /**
   * EnvÃ­a la respuesta actual al backend y avanza automÃ¡ticamente a la siguiente pregunta.
   * 
   * Proceso:
   * 1. Valida que haya texto en la respuesta
   * 2. EnvÃ­a POST a backend con responseService.submitResponse
   * 3. Actualiza la UI refrescando datos de entrevista
   * 4. Limpia respuesta temporal del estado local
   * 5. Avanza a siguiente pregunta automÃ¡ticamente
   * 6. Si es Ãºltima pregunta, permanece en ella (el usuario debe hacer clic en "Finalizar")
   * 
   * @async
   * @function handleSaveResponse
   * @returns {Promise&lt;void>}
   * @sideEffects
   * - POST /responses/submit (Backend)
   * - setSubmitting(true) â†’ setSubmitting(false): Disable UI durante envÃ­o
   * - fetchInterview(): Actualiza interview y questions
   * - setResponses(): Limpia respuesta temporal guardada
   * - setCurrentQuestion(): Avanza a siguiente pregunta si no es Ãºltima
   * - toast.*(): Muestra notificaciones (Ã©xito/error/warning)
   * 
   * @throws {Error} Si la respuesta estÃ¡ vacÃ­a o el envÃ­o al backend falla
   * 
   * @example
   * // Usuario hace clic en "Siguiente" â†’ handleSaveResponse envÃ­a respuesta al backend
   * &lt;button onClick={handleSaveResponse} disabled={submitting}>Siguiente&lt;/button>
   */
  const handleSaveResponse = async () => {
    const resp = (responses[currentQuestion] || '').trim();
    if (!resp) {
      toast.warning('Introduce una respuesta antes de continuar');
      return;
    }
    try {
      setSubmitting(true);
      const questionId = question._id;
      await responseService.submitResponse({
        questionId,
        interviewId,
        responseText: resp
      });
      toast.success('Respuesta guardada');
      await fetchInterview();
      // Limpiar el estado temporal despuÃ©s de guardar
      setResponses((prev) => {
        const newResponses = { ...prev };
        delete newResponses[currentQuestion];
        return newResponses;
      });
      
      // âœ… NUEVO: Avanzar automÃ¡ticamente a la siguiente pregunta
      if (currentQuestion &lt; questions.length - 1) {
        setCurrentQuestion(currentQuestion + 1);
      }
    } catch (error) {
      toast.error(error.response?.data?.message || 'Error al guardar respuesta');
    } finally {
      setSubmitting(false);
    }
  };

  /**
   * Finaliza la entrevista completando todas las respuestas y generando feedback con IA.
   * 
   * Proceso de validaciÃ³n y finalizaciÃ³n:
   * 1. Valida que todas las preguntas tengan al menos una respuesta
   * 2. Si hay preguntas sin responder, navega a la primera sin respuesta
   * 3. Si todas estÃ¡n respondidas:
   *    - EnvÃ­a POST a backend para generar feedback con Google Gemini IA
   *    - Actualiza estado de entrevista a "completed"
   *    - Recarga datos de la entrevista para mostrar resultados
   * 4. Muestra notificaciones del progreso
   * 5. Maneja errores y muestra mensajes al usuario
   * 
   * @async
   * @function handleCompleteInterview
   * @returns {Promise&lt;void>}
   * @sideEffects
   * - POST /responses/feedback (Backend: Genera feedback con IA)
   * - PUT /interviews/:id/status (Backend: Marca como completada)
   * - setSubmitting(true) â†’ setSubmitting(false): Disable UI
   * - fetchInterview(): Recarga datos para mostrar resultados
   * - setCurrentQuestion(): Navega a primera pregunta sin respuesta si hay validaciÃ³n
   * - toast.*(): Notificaciones de progreso y errores
   * 
   * @throws {Error} Si falla la generaciÃ³n de feedback o actualizaciÃ³n de estado
   * 
   * @example
   * // Usuario hace clic en "Finalizar entrevista" â†’ valida â†’ genera feedback â†’ muestra resultados
   * &lt;button onClick={handleCompleteInterview} disabled={submitting || !allAnswered}>
   *   Finalizar Entrevista
   * &lt;/button>
   */
  const handleCompleteInterview = async () => {
    // âœ… Verificar si hay preguntas sin responder
    const firstUnansweredIndex = questions.findIndex((q, idx) => {
      const qResponses = q?.responses || [];
      const lastSaved = qResponses.length > 0 ? qResponses[qResponses.length - 1]?.responseText : null;
      const temp = responses[idx];
      return !(temp &amp;&amp; temp.trim().length > 0) &amp;&amp; !(lastSaved &amp;&amp; lastSaved.trim().length > 0);
    });

    // Si hay preguntas sin responder, navegar a la primera
    if (firstUnansweredIndex !== -1) {
      toast.warning(`Tienes preguntas sin responder. Ir a pregunta ${firstUnansweredIndex + 1}`);
      setCurrentQuestion(firstUnansweredIndex);
      return;
    }

    // Si todas estÃ¡n respondidas, generar feedback y completar
    try {
      setSubmitting(true);
      toast.info('â³ Generando puntuaciones y feedback... Esto puede tomar 1-2 minutos.');
      
      // âœ… Generar feedback antes de completar
      try {
        await responseService.generateInterviewFeedback(interviewId);
      } catch (feedbackError) {
        // Si el error es timeout, mostrar mensaje mÃ¡s especÃ­fico
        if (feedbackError.message &amp;&amp; feedbackError.message.includes('timeout')) {
          toast.warning('âš ï¸ El servidor estÃ¡ procesando tu feedback. Si no ves resultados, por favor espera unos minutos.');
        } else {
          throw feedbackError;
        }
      }
      
      // Actualizar estado a completado
      await interviewService.updateInterviewStatus(interviewId, { status: 'completed' });
      
      toast.success('Â¡Entrevista completada! Puedes ver tus resultados en el listado de entrevistas.');
      
      // Redirigir al listado de entrevistas
      setTimeout(() => navigate('/interviews'), 1500);
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message || 'Error al completar la entrevista';
      toast.error(errorMessage);
      console.error('Error completing interview:', error);
    } finally {
      setSubmitting(false);
    }
  };

  /**
   * Inicia o detiene la captura de voz mediante Web Speech API.
   * 
   * Comportamiento:
   * - Si estÃ¡ escuchando: Detiene el reconocimiento (llama a recognitionRef.current.stop())
   * - Si no estÃ¡ escuchando: Inicia nueva sesiÃ³n de grabaciÃ³n
   *   - Limpia respuestas anteriores (userAnswer, elapsedTime)
   *   - Inicia nuevo proceso de reconocimiento (recognitionRef.current.start())
   *   - Actualiza UI (isListening = true, muestra "Escuchando...")
   * 
   * Nota: La parada y procesamiento de resultados es manejado por el evento onend
   * de recognitionRef.current configurado en el useEffect de inicializaciÃ³n.
   * 
   * @function handleListenToggle
   * @returns {void}
   * @sideEffects
   * - recognitionRef.current.start() o .stop(): Controla Web Speech API
   * - setUserAnswer(''): Limpia transcripciÃ³n anterior
   * - setElapsedTime(0): Reinicia contador de tiempo de grabaciÃ³n
   * - setIsListening(true): Actualiza estado a escuchando
   * - setVoiceStatus(): Muestra estado del micrÃ³fono
   * 
   * @example
   * // Usuario hace clic en botÃ³n de micrÃ³fono
   * &lt;button onClick={handleListenToggle} className={isListening ? 'active' : ''}>
   *   MicrÃ³fono
   * &lt;/button>
   */
  const handleListenToggle = () => {
    if (isListening) {
      recognitionRef.current?.stop();
    } else if (recognitionRef.current) {
      setUserAnswer('');
      userAnswerRef.current = '';
      setElapsedTime(0);
      recognitionRef.current.start();
      setIsListening(true);
      setVoiceStatus('Escuchando...');
    }
  };

  /**
   * Acepta la transcripciÃ³n de voz y la transfiere al textarea.
   * 
   * Proceso:
   * 1. Valida que haya texto transcrito (no vacÃ­o)
   * 2. Asigna el texto de userAnswer al responses[currentQuestion]
   * 3. Limpia estados de confirmaciÃ³n (isConfirming = false, userAnswer = '')
   * 4. Reinicia cronÃ³metro de grabaciÃ³n (elapsedTime = 0)
   * 5. Actualiza mensaje de estado
   * 
   * Nota: El texto confirmado NO se envÃ­a inmediatamente al backend.
   * Se envÃ­a cuando el usuario hace clic en "Siguiente" (handleSaveResponse).
   * 
   * @function handleConfirmAnswer
   * @returns {void}
   * @sideEffects
   * - setResponses(): Asigna userAnswer a responses[currentQuestion]
   * - setIsConfirming(false): Oculta botones de confirmaciÃ³n
   * - setUserAnswer(''): Limpia respuesta temporal de voz
   * - setElapsedTime(0): Reinicia contador
   * - setVoiceStatus(): Actualiza mensaje a usuario
   * 
   * @example
   * // Usuario dice algo, se transcribe, hace clic en "Confirmar"
   * &lt;button onClick={handleConfirmAnswer} disabled={!userAnswer.trim()}>
   *   âœ“ Confirmar
   * &lt;/button>
   */
  const handleConfirmAnswer = () => {
    if (!userAnswer.trim()) return;
    setResponses((prev) => ({
      ...prev,
      [currentQuestion]: userAnswer.trim()
    }));
    setIsConfirming(false);
    setUserAnswer('');
    userAnswerRef.current = '';
    setElapsedTime(0);
    setVoiceStatus('Respuesta confirmada. Procede al siguiente paso.');
  };

  /**
   * Rechaza la transcripciÃ³n de voz y permite reintentar.
   * 
   * Proceso:
   * 1. Oculta pantalla de confirmaciÃ³n (isConfirming = false)
   * 2. Limpia transcripciÃ³n actual (userAnswer = '')
   * 3. Reinicia cronÃ³metro (elapsedTime = 0)
   * 4. Muestra mensaje invitando a reintentar
   * 
   * El usuario puede hacer clic en el micrÃ³fono nuevamente para intentar otra grabaciÃ³n.
   * 
   * @function handleRetryAnswer
   * @returns {void}
   * @sideEffects
   * - setIsConfirming(false): Oculta confirmaciÃ³n
   * - setUserAnswer(''): Limpia transcripciÃ³n
   * - setElapsedTime(0): Reinicia tiempo
   * - setVoiceStatus(): Muestra mensaje de reintentar
   * 
   * @example
   * // Usuario rechaza transcripciÃ³n y hace clic en "Reintentar"
   * &lt;button onClick={handleRetryAnswer}>
   *   â†º Reintentar
   * &lt;/button>
   */
  const handleRetryAnswer = () => {
    setIsConfirming(false);
    setUserAnswer('');
    userAnswerRef.current = '';
    setElapsedTime(0);
    setVoiceStatus('Puedes empezar a grabar de nuevo cuando quieras.');
  };

  if (loading) {
    return (
      &lt;div className="interview-session__loading">
        &lt;div className="interview-session__loading-spinner">&lt;/div>
      &lt;/div>
    );
  }
  if (!interview || !questions.length) {
    return &lt;div className={`interview-session__empty ${isDark ? 'interview-session__empty--dark' : ''}`}>{t('interview.noInterviews')}&lt;/div>;
  }

  // Si la entrevista estÃ¡ completada, mostrar vista de resultados completa
  if (isCompleted) {
    return (
      &lt;div className={`interview-session ${isDark ? 'interview-session--dark' : ''}`}>
        &lt;div className="interview-session__container interview-session__container--full">
          &lt;div className="interview-session__header">
            &lt;div className="interview-session__title-row">
              &lt;h1 className={`interview-session__title ${isDark ? 'interview-session__title--dark' : ''}`}>
                {interview?.title}
              &lt;/h1>
              &lt;button
                onClick={() => navigate('/interviews')}
                className="interview-session__exit-button"
              >
                &lt;FiX /> {t('interview.exit')}
              &lt;/button>
            &lt;/div>
            &lt;p className={`interview-session__subtitle ${isDark ? 'interview-session__subtitle--dark' : ''}`}>
              Resultados de la entrevista - {questions.length} preguntas
            &lt;/p>
          &lt;/div>

          &lt;div className={`interview-session__results-container ${isDark ? 'interview-session__results-container--dark' : ''}`}>
            {questions.map((q, idx) => {
              const allResponses = q?.responses || [];
              return (
                &lt;div key={idx} className={`interview-session__result-card ${isDark ? 'interview-session__result-card--dark' : ''}`}>
                  &lt;div className="interview-session__result-header">
                    &lt;span className="interview-session__result-number">{idx + 1}&lt;/span>
                    &lt;div className="interview-session__result-info">
                      &lt;h3 className={`interview-session__result-question ${isDark ? 'interview-session__result-question--dark' : ''}`}>
                        {q?.questionText || q?.question}
                      &lt;/h3>
                      &lt;span className={`interview-session__result-difficulty ${isDark ? 'interview-session__result-difficulty--dark' : ''}`}>
                        {t('interview.difficulty')}: {q?.difficulty || 'unknown'}
                      &lt;/span>
                    &lt;/div>
                  &lt;/div>
                  
                  {allResponses.length === 0 ? (
                    &lt;div className={`interview-session__result-answer ${isDark ? 'interview-session__result-answer--dark' : ''}`}>
                      &lt;span className="interview-session__no-response">{t('interview.noResponse')}&lt;/span>
                    &lt;/div>
                  ) : (
                    &lt;div className="interview-session__result-responses">
                      {allResponses.map((resp, respIdx) => (
                        &lt;div key={respIdx} className={`interview-session__result-answer ${isDark ? 'interview-session__result-answer--dark' : ''}`}>
                          &lt;div className="interview-session__result-answer-header">
                            &lt;span className="interview-session__response-badge">Respuesta {respIdx + 1}&lt;/span>
                            {resp?.score !== undefined &amp;&amp; (
                              &lt;span className={`interview-session__score-badge ${resp.score >= 70 ? 'interview-session__score-badge--good' : resp.score >= 50 ? 'interview-session__score-badge--medium' : 'interview-session__score-badge--low'}`}>
                                {resp.score}/100
                              &lt;/span>
                            )}
                          &lt;/div>
                          &lt;p className="interview-session__result-text">{resp?.responseText || &lt;span className="interview-session__no-response">{t('interview.noResponse')}&lt;/span>}&lt;/p>
                          {resp?.feedback &amp;&amp; (
                            &lt;div className={`interview-session__feedback ${isDark ? 'interview-session__feedback--dark' : ''}`}>
                              &lt;strong>Feedback:&lt;/strong> {resp.feedback}
                            &lt;/div>
                          )}
                        &lt;/div>
                      ))}
                    &lt;/div>
                  )}
                &lt;/div>
              );
            })}
          &lt;/div>
        &lt;/div>
      &lt;/div>
    );
  }

  // Vista normal para entrevista en progreso
  const progress = ((currentQuestion + 1) / questions.length) * 100;

  return (
    &lt;div className={`interview-session ${isDark ? 'interview-session--dark' : ''}`}>
      &lt;div className="interview-session__container">
        &lt;div className="interview-session__header">
          &lt;div className="interview-session__title-row">
            &lt;h1 className={`interview-session__title ${isDark ? 'interview-session__title--dark' : ''}`}>
              {interview?.title}
            &lt;/h1>
            &lt;span className={`interview-session__question-counter ${isDark ? 'interview-session__question-counter--dark' : ''}`}>
              {currentQuestion + 1} / {questions.length}
            &lt;/span>
          &lt;/div>
          &lt;div className={`interview-session__progress-track ${isDark ? 'interview-session__progress-track--dark' : ''}`}>
            &lt;div
              className="interview-session__progress-bar"
              style={{ width: `${progress}%` }}
            >&lt;/div>
          &lt;/div>
        &lt;/div>

        &lt;div className={`interview-session__card ${isDark ? 'interview-session__card--dark' : ''}`}>
          &lt;div className="interview-session__question-header">
            &lt;div className="interview-session__question-number">
              {currentQuestion + 1}
            &lt;/div>
            &lt;p className={`interview-session__question-difficulty ${isDark ? 'interview-session__question-difficulty--dark' : ''}`}>
              {t('interview.difficulty')}: {question?.difficulty || 'unknown'}
            &lt;/p>
          &lt;/div>

          &lt;h2 className={`interview-session__question-text ${isDark ? 'interview-session__question-text--dark' : ''}`}>
            {question?.questionText || question?.question || 'Question not found'}
          &lt;/h2>

          &lt;div className="interview-session__answer-section">
            &lt;label className={`interview-session__answer-label ${isDark ? 'interview-session__answer-label--dark' : ''}`}>
              {t('interview.answer')}
            &lt;/label>

            {isCompleted ? (
              // Este bloque ya no se usa, la vista completa estÃ¡ arriba
              null
            ) : isInProgress ? (
              &lt;div>
                {/* Mostrar Ãºltima respuesta guardada si existe */}
                {responseSaved &amp;&amp; (
                  &lt;div className={`interview-session__last-response ${isDark ? 'interview-session__last-response--dark' : ''}`}>
                    &lt;p className="interview-session__last-response-title">Ãšltima respuesta enviada:&lt;/p>
                    &lt;p className="interview-session__last-response-text">{responseSaved}&lt;/p>
                  &lt;/div>
                )}

                {/* Ãrea de entrada con reconocimiento de voz o textarea */}
                {isConfirming ? (
                  &lt;div className={`interview-session__confirming-box ${isDark ? 'interview-session__confirming-box--dark' : ''}`}>
                    &lt;p className="interview-session__confirming-title">{t('interview.pendingConfirmation')}&lt;/p>
                    &lt;p className="interview-session__confirming-text">{userAnswer}&lt;/p>
                  &lt;/div>
                ) : (
                  &lt;div className="interview-session__textarea-wrapper">
                    &lt;textarea
                      value={localResponse || userAnswer}
                      onChange={handleResponseChange}
                      disabled={isListening || submitting}
                      className={`interview-session__textarea ${isDark ? 'interview-session__textarea--dark' : ''}`}
                      rows="6"
                      placeholder={t('interview.unansweredQuestion')}
                    />
                    &lt;button
                      onClick={handleListenToggle}
                      disabled={submitting}
                      className={`interview-session__mic-button-inside ${isListening ? 'interview-session__mic-button-inside--listening' : ''}`}
                      title={isListening ? t('interview.stop') : t('interview.record')}
                    >
                      &lt;MicrophoneIcon />
                    &lt;/button>
                  &lt;/div>
                )}

                {/* Estado del reconocimiento de voz */}
                {voiceStatus &amp;&amp; (
                  &lt;div className={`interview-session__voice-status ${isDark ? 'interview-session__voice-status--dark' : ''}`}>
                    {voiceStatus}
                  &lt;/div>
                )}

                {/* Tiempos */}
                {(isListening || isConfirming) &amp;&amp; (
                  &lt;div className={`interview-session__timers ${isDark ? 'interview-session__timers--dark' : ''}`}>
                    &lt;span>{t('interview.responseTime')}: {formatTime(elapsedTime)}&lt;/span>
                    &lt;span>{t('interview.totalTime')}: {formatTime(totalTime)}&lt;/span>
                  &lt;/div>
                )}

                {/* Botones de acciÃ³n */}
                &lt;div className="interview-session__actions">
                  {isConfirming ? (
                    &lt;>
                      &lt;button
                        onClick={handleRetryAnswer}
                        className="interview-session__button interview-session__button--retry"
                      >
                        {t('interview.retryAnswer')}
                      &lt;/button>
                      &lt;button
                        onClick={handleConfirmAnswer}
                        className="interview-session__button interview-session__button--confirm"
                      >
                        {t('interview.confirmAnswer')}
                      &lt;/button>
                    &lt;/>
                  ) : (
                    &lt;button
                      type="button"
                      onClick={handleSaveResponse}
                      disabled={submitting || localResponse.trim().length === 0}
                      className="interview-session__button interview-session__button--save"
                    >
                      {t('interview.saveResponse')}
                    &lt;/button>
                  )}
                &lt;/div>
              &lt;/div>
            ) : null}
          &lt;/div>

          {/**
           * SecciÃ³n de navegaciÃ³n entre preguntas.
           * Muestra botones para ir a pregunta anterior/siguiente segÃºn posiciÃ³n actual.
           * 
           * LÃ³gica:
           * - BotÃ³n "Anterior" aparece si currentQuestion > 0
           * - BotÃ³n "Siguiente" aparece si currentQuestion &lt; ÃºltimaPreg
           * - En Ãºltima pregunta, desaparece "Siguiente" y aparece "Finalizar"
           * 
           * Nota: Los clics en navegaciÃ³n NO guardan respuesta. El usuario debe hacer
           * clic en "Siguiente" para guardar. Esta navegaciÃ³n es solo para moverse rÃ¡pido
           * sin guardar (solo cambia visualizaciÃ³n de pregunta en UI).
           * 
           * Botones inline:
           * - onClick={() => setCurrentQuestion(currentQuestion - 1)} â†’ Va a pregunta anterior
           * - onClick={() => setCurrentQuestion(currentQuestion + 1)} â†’ Va a pregunta siguiente
           */}
          &lt;div className="interview-session__nav">
            {currentQuestion > 0 &amp;&amp; (
              &lt;button
                onClick={() => setCurrentQuestion(currentQuestion - 1)}
                className={`interview-session__nav-button ${isDark ? 'interview-session__nav-button--dark' : ''}`}
              >
                &lt;FiArrowLeft /> {t('interview.previousQuestion')}
              &lt;/button>
            )}
            {currentQuestion &lt; questions.length - 1 &amp;&amp; (
              &lt;button
                onClick={() => setCurrentQuestion(currentQuestion + 1)}
                className={`interview-session__nav-button ${isDark ? 'interview-session__nav-button--dark' : ''}`}
              >
                {t('interview.nextQuestion')} &lt;FiArrowRight />
              &lt;/button>
            )}
          &lt;/div>

          {/**
           * BotÃ³n para completar la entrevista.
           * 
           * Visibilidad: Solo aparece en la Ãºltima pregunta (currentQuestion === questions.length - 1)
           * 
           * Estados del botÃ³n:
           * 1. Todas respondidas: "âœ“ Finalizar Entrevista" - Habilitado
           *    - onClick={handleCompleteInterview} genera feedback con IA
           * 
           * 2. Hay sin responder: "! Responde todas las preguntas" - Deshabilitado
           *    - Muestra tooltip indicando que faltan respuestas
           * 
           * Comportamiento al hacer clic:
           * - handleCompleteInterview() valida respuestas faltantes
           * - Si hay sin responder: navega a la primera sin responder
           * - Si todas respondidas: genera feedback con Google Gemini y marca completada
           * 
           * @component BotÃ³n inline condicional
           * @disabled {boolean} submitting OR !allAnswered
           */}
          {currentQuestion === questions.length - 1 &amp;&amp; isInProgress &amp;&amp; (
            &lt;div style={{ marginTop: '1rem', display: 'flex', justifyContent: 'center' }}>
              &lt;button
                onClick={handleCompleteInterview}
                disabled={submitting}
                className="interview-session__complete-button"
                title={allAnswered ? 'Completar y enviar entrevista' : 'Haz clic para ir a las preguntas sin responder'}
              >
                {allAnswered ? (
                  &lt;>
                    &lt;FiCheck /> {t('interview.completeInterview')}
                  &lt;/>
                ) : (
                  &lt;>
                    &lt;FiX /> Faltan preguntas por responder ({questions.filter((q, idx) => {
                      const qResponses = q?.responses || [];
                      const lastSaved = qResponses.length > 0 ? qResponses[qResponses.length - 1]?.responseText : null;
                      const temp = responses[idx];
                      return (temp &amp;&amp; temp.trim().length > 0) || (lastSaved &amp;&amp; lastSaved.trim().length > 0);
                    }).length}/{questions.length})
                  &lt;/>
                )}
              &lt;/button>
            &lt;/div>
          )}
        &lt;/div>
      &lt;/div>
    &lt;/div>
  );
};

export default InterviewSession;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-App.html">App</a></li><li><a href="module-Header.html">Header</a></li><li><a href="module-Home.html">Home</a></li><li><a href="module-apiClient.html">apiClient</a></li><li><a href="module-components_Header.html">components/Header</a></li><li><a href="module-components_StatCard.html">components/StatCard</a></li><li><a href="module-main.html">main</a></li><li><a href="module-pages_InterviewSession.html">pages/InterviewSession</a></li><li><a href="module-pages_Settings.html">pages/Settings</a></li><li><a href="module-services.html">services</a></li><li><a href="module-stores.html">stores</a></li><li><a href="module-useDashboard.html">useDashboard</a></li><li><a href="module-useHeader.html">useHeader</a></li><li><a href="module-useHome.html">useHome</a></li></ul><h3>Externals</h3><ul><li><a href="external-i18next.html">i18next</a></li><li><a href="external-initReactI18next.html">initReactI18next</a></li></ul><h3>Namespaces</h3><ul><li><a href="i18nConfig.html">i18nConfig</a></li><li><a href="module-services-aiService.html">aiService</a></li><li><a href="module-services-authService.html">authService</a></li><li><a href="module-services-interviewService.html">interviewService</a></li><li><a href="module-services-responseService.html">responseService</a></li><li><a href="module-services-statsService.html">statsService</a></li><li><a href="module-services-subscriptionService.html">subscriptionService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Interviews">Interviews</a></li><li><a href="global.html#Login">Login</a></li><li><a href="global.html#Register">Register</a></li><li><a href="global.html#StatCard">StatCard</a></li><li><a href="global.html#Subscription">Subscription</a></li><li><a href="global.html#default">default</a></li><li><a href="global.html#fallbackLng">fallbackLng</a></li><li><a href="global.html#getCurrentLanguage">getCurrentLanguage</a></li><li><a href="global.html#interpolation">interpolation</a></li><li><a href="global.html#lng">lng</a></li><li><a href="global.html#resources">resources</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Thu Dec 11 2025 23:00:00 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
